;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;

; SET pin 0 should be mapped to your LED GPIO

; //BCRASH Wait, dang, I just remembered - I've seen partially changed bytes get sent. :/ This means our "always send" method may not work.  ...Unless I DO turn WR# on/off?
; //CHECK Turn WR# on/off?

.program write2ftdi

/*
Times:
initial: 6720090 B/s

*/

; .side_set 2 opt
.side_set 4
; //LEAK Possible optimizations: loop write several times before read
; //       That y-- thing I mention in the middle
;                             CS# A0 RD# WR#
    set x, 0             side 0b1011 [0]
    ; pull Block           side 0b1011 [0]
.wrap_target
beginning:
;                             CS# A0 RD# WR#
    ; out pins, 8          side 0b1011 [0]
    mov pins, x          side 0b1011 [0]
    
    nop                  side 0b0011 [0] ; CS# down

    nop                  side 0b0010 [1] ; WR# down
    nop                  side 0b0010 [1]
    nop                  side 0b0010 [1]
    nop                  side 0b0010 [0]

    nop                  side 0b0011 [0] ; WR# up


    ; Read state              CS# A0 RD# WR#

    set y, 0             side 0b1011 [0] ; CS# up
    mov osr, y           side 0b1011 [0] ; 00000000
    out pindirs 8        side 0b1011 [1] ; Hopefully the possible conflict on pins 5-7 isn't a problem

checkState:
    nop                  side 0b0111 [0] ; CS# down, A0 up

    nop                  side 0b0101 [1] ; RD# down
    nop                  side 0b0101 [1]

    set y, 1             side 0b0101 [0]
    jmp pin rd           side 0b0101 [1]
    set y, 0             side 0b0101 [1] ; pin was 0: no space
rd:

    nop                  side 0b0111 [1] ; RD# up
    nop                  side 0b0111 [1]

    nop                  side 0b1011 [0] ; CS# up, A0 down
    nop                  side 0b1011 [1]

    ; //RAINY //LEAK I think I could use y-- to save an instruction
    jmp !y checkState    side 0b1011 [0]

    ; Has space

    set y, 0             side 0b1011 [0]
    mov osr, !y          side 0b1011 [0] ; 11111111
    out pindirs 8        side 0b1011 [1]

    ; Continue

    ; pull Block           side 0b1011 [0] ; CS# up
    jmp x--, beginning   side 0b1011 [0] ; CS# up
.wrap

; ;                             CS# A0 WR#
; .wrap_target
; ;                             CS# A0 WR#
;     nop                  side 0b101
;     nop                  side 0b001
;     nop                  side 0b000 [3]
;     nop                  side 0b001
;     nop                  side 0b101
; .wrap

; ;                             CS# A0 RD# WR#
; .wrap_target
; ;                             CS# A0 RD# WR#
;     nop                  side 0b1011

;     nop                  side 0b0011 [0] ; CS# down
    
;     nop                  side 0b0010 [1] ; WR# down
;     nop                  side 0b0010 [1]
;     nop                  side 0b0010 [1]
;     nop                  side 0b0010 [0]

;     nop                  side 0b0011 [0] ; WR# up

;     nop                  side 0b1011 [1] ; CS# up
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
;     nop                  side 0b1011 [1]
; .wrap

; ;                             CS# A0 WR#
; .wrap_target
; ;                             CS# A0 WR#
;     nop                  side 0b101 [3]
; .wrap

; ;                             CS# A0 RD# WR#
; .wrap_target
; ;                             CS# A0 RD# WR#
;     nop                  side 0b0010 [1]
; .wrap


% c-sdk {
// this is a raw helper function for use by the user which sets up the GPIO output, and configures the SM to output on a particular pin

void write2ftdi_program_init(PIO pio, uint sm, uint offset, uint data_pins_8, uint wr_rd_a0_cs_pin) {
   pio_sm_config c = write2ftdi_program_get_default_config(offset);
   int N = 8;//
   for (int i = 0; i < N; i++) {
       pio_gpio_init(pio, data_pins_8+i);
   }
   pio_sm_set_consecutive_pindirs(pio, sm, data_pins_8, N, true);
   sm_config_set_out_pins(&c, data_pins_8, N);

//   pio_gpio_init(pio, clk_then_wr_pin);
//   pio_sm_set_consecutive_pindirs(pio, sm, clk_then_wr_pin, 1, false);
//   sm_config_set_in_pins(&c, clk_then_wr_pin);
      
   pio_gpio_init(pio, wr_rd_a0_cs_pin);
   pio_gpio_init(pio, wr_rd_a0_cs_pin+1);
   pio_gpio_init(pio, wr_rd_a0_cs_pin+2);
   pio_gpio_init(pio, wr_rd_a0_cs_pin+3);
   pio_sm_set_consecutive_pindirs(pio, sm, wr_rd_a0_cs_pin, 4, true);
   sm_config_set_set_pins(&c, wr_rd_a0_cs_pin, 4);
   sm_config_set_sideset_pins(&c, wr_rd_a0_cs_pin);

   //sm_config_set_jmp_pin(&c, comms_pin);
   sm_config_set_jmp_pin(&c, data_pins_8+6); // data pin 6
   
   pio_sm_init(pio, sm, offset, &c);
}
%}
